## Basic Paxos

### 概览

paxos 算法将节点分为三类：

- 提案节点（proposal）：提案结点提出提案，该提案一旦被接受，就是不可丢失也不可变的。这里的提案应该类似于一种日志记录的操作，一条提案被接受就是一条日志被记录

- 决策节点（acceptor）：对提案发表通古或者否决的结点，一旦一个提案被一半以上的人接受，那么我们就说该提案被接受（accept），最终所有结点都会接受它。自己可以是自己的决策结点。

- 学习结点（learner）：不参与提案和决策，只是从已经记录的提案中学习。

  > 例如说刚从网络分区中恢复的结点，或者说新加入的结点就是这个状态。

所有的结点都可以有这三种状态：自己可以提案，也可以评判它人提案，掉线后恢复就变成学习结点。系统的结点个数一般设定为奇数个，并且开始时所有结点都知道这个系统有多少结点。



### 难点

- 系统内部的结点通信不可靠

  > 系统内结点的通信允许有：
  >
  > 1. 消息延迟
  > 2. 消息丢失
  >
  > 但是不允许有消息出错，即没有拜占庭故障。

- 系统外部的客户并发访问

  > 如果系统外有许多客户。如果只有一个客户，那么它的访问必然是串行的，那么只要运用少数服从多数即可，因为我们可以确定提案的顺序。



### 规则

Paxos 算法包括两个阶段：Prepare 和 Accept，分别对应两个请求。

#### Prepare

##### 语义

Prepare 请求的语义是 `我准备提出对某值提案，是否允许？`。收到的回复只有两种：1. `可以`、2.`该值已被设定为xxx`。

##### 过程

当某个提案节点要提出提案时，它需要将这个提案附加一个**递增**且**全局唯一**的 `ID`（假设为 `n`），并广播给所有决策节点。

当决策节点收到后，如果收到的提案 ID 并**不是**决策节点收到的最大的 ID，那么允许其对此 Prepare **不予理会**。反之则会给提案节点一个应答（Promise），应答内容是：

- 已经**接受的（accept）**提案中 ID 最大的那个提案的 ID 和所设的的值：`(id，value)`。如果该值没有被设定过，那么返回空值

  > 这里的已经接受的提案是指自身已经返回 Accept 响应的提案

  

并且决策节点收到提案 ID 后会有两个性质：

- 不会再响应 ID **小于等于** `n` 的 Prepare 请求
- 不会再响应 ID **小于** `n` 的 Accept 请求

当提案结点收到了大于一半的结点的 Promise 回复后，就可以开始发送 Accept 请求。



#### Accept

##### 语义

Accept 请求的语义是 `请把某值设定为xxx`，这个请求的结果有两种：1.`可以`、2.不回复

##### 过程

任何一个结点收到多数派 Promise 应答时：

- 如果提案节点发现所有响应自己提案的结点返回的值**都是**空，那么它就可以设定值，将设定的值和提案 ID 组成一个二元组`(id, value)` 以 Accept 请求的方式广播给所有结点，要求它们接受自己的值。

  > 这里的 id 是指自己曾经提案的那个 ID

- 如果提案节点发现响应自己提案的结点返回的值中存在一个节点已经包含值，那么它必须从所有应答中找出提案 ID 最大的值 value，并且组成 `(id, value)` 再次广播出去。

  > 这里的 id 是指自己曾经提案的那个 ID

每个决策节点在遇到 Accept 请求时，先查看提案 ID ，如果不是自己见到过的最大的，那么允许不予响应。是最大的的话就返回一个 Accept 响应。

如果提案节点的 Accept 请求得到多数派的 Accept 响应的话，那么此时就代表系统认定的值被确定。



#### Learn

接受提案是单个接收者的行为，只有当多数派接收者都接受某一提案时，我们才说该提案被认定（chosen）。那么如何学习到已经被认定的值呢？

原论文给出的方法是接受者一旦接受一个提案就广播这个提案给学习者，一旦学习者收到多数派的同一个提案，那么就认为该提案被系统选定。





### 理解

#### 为什么 Paxos 需要多数派接受某个值才代表系统认定(chosen)该值？

多数派接受某个值代表它们对该值的 accept 请求作出响应。其中的数学原理是：**两个过半数集合必然存在交集**。

一个 value 被认定需要被半数以上的 Acceptor 接受。 由于一个集合不可能同时存在两个半数以上的子集同时接受两个不同value，所以如果一个值被半数以上 Acceptor 接受，则意味这此时被认定的 value 是唯一的。

这也就意味着，如果有起初有偶数个结点，那么 value 必须严格多于一半接收者接受才能被认定。





#### Paxos 如何保证系统认定的值一致？

**如果系统认定值为 $v$，那么之后的提案所认定的值也要是 $v$**。可以分解为以下两个要求：

-  **如果选定了一个值为 $v$ 的提案，那么任意接受者接受（accept）的编号更大的提案，其值也应该是 $v$**
-  **如果选定了一个值为 $v$ 的提案，那么任意提案者发起的编号更大的提案，其值也应该是 $v$**。（Accept 二阶段）

从逻辑关系上说，如果发起的提案值都是 $v$，那么接受的提案者也只能是 $v$，因此只需要满足第二个要求即可。

要满足该要求，就需要知悉已经接受的最大ID的提案的值，而这正是在 Prepare 二阶段获悉的：只要返回的 Promise 中存在 `(id, value)` 二元组（这里是指最大的那个），就将自己要发起的 Accept 请求要设定的值也选定为 value。





#### 为什么一定要多数派承诺 Promise 响应才能发 Accept 请求？





#### 全局唯一的 ID 怎么生成？

可以用 （时间戳，服务器ID）表示，这样即使时间戳相同，由于服务器 ID 不同也会使得全局 ID 唯一。





### 举例

假设一个分布式系统有五个节点，分别命名为 S1、S2、S3、S4、S5。这个例子中只讨论正常通信的场景，不涉及网络分区



#### 情况一

这种情况是最正常的情况，一个结点的提议被接受，后续阶段结点再次提议时被告知该值已被设定。

假设 S1 提出提案，S1，S2，S3 返回 Promise，并且也都回复 Accept 响应。

后续 S5 想要再次对值进行提案，由于需要多数派同意，所以必然会遇到某个结点（这里假设 S3）回复 Prepare，内容是该值已被设定为 X。S5 收到后只好接受该值并广播，使得 S4 也知道值是 X。

![image-20230305172314846](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20230305172314846.png)

#### 情况二

X 被接受并不是因为多数派返回了 Accept 响应，而是新的提案者看见了它，即收到的 Promise 应答中包含有之前的设定值。

比如下图，即使只有一个结点（S3）批准了该值，但是新提案者收到了 S3 的 Promise 响应，所以也把自己选定的值设为 X 并且再次广播。

可以看出，即使并没有多数派 Accept 响应该提案，但只要新提案者发现之前的旧值，最终这个值就会被接受

![image-20230305172841573](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20230305172841573.png)



#### 情况三

顺着情况二的思路，既然新提案者可以看见旧值，那么也有可能看不见旧值，此时新提案者可以自己设定值

比如 S3 还没有批准，S5 已经收到 S3、S4 和 S5 的 Promise 响应并且内部都为空，这是 S5 设定值为 Y，后续即使 S1 的 Accept 请求到达 S3，S3 会忽略这个请求，因为该请求的 ID 已经小于 S3 所见过的了（即 4.5），由于 S5 的 Accept 广播到所有结点，整个系统最终**几乎**会对取值为 Y 达成共识。

![image-20230305173200914](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20230305173200914.png)





#### 情况四

之所以是说 **几乎** 是因为这个过程理论上可以无限重复，从而形成活锁。

即 S1 和 S5 交替提出提案：

S1 提出提案后并且获得大多数 Promise 响应后， S5 再提出，由于 S5 的 ID 更大，其他节点不会再响应 S1 发出的 Accept 请求

S5 提出提案并且获得大多数 Promise 响应后，S1 又继续提出，由于 S1 的 ID 更大，其他节点不再响应 S5 发出的 Accept 请求

依次类推，理论上可以无限推进，但是现实中这几乎不会发生，或者循环若干次这种循环就被打破。

![image-20230305173755477](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20230305173755477.png)
